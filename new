package com.danone.aemaacs.core.models.impl;

import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import javax.annotation.PostConstruct;
import javax.jcr.Session;

import org.apache.sling.api.SlingHttpServletRequest;
import org.apache.sling.api.resource.Resource;
import org.apache.sling.api.resource.ResourceResolver;
import org.apache.sling.api.resource.ValueMap;
import org.apache.sling.models.annotations.DefaultInjectionStrategy;
import org.apache.sling.models.annotations.Model;
import org.apache.sling.models.annotations.injectorspecific.Self;

import com.danone.aemaacs.core.models.CFModelDataSource;
import com.danone.aemaacs.core.utils.ContentFragmentUtils;
import com.day.cq.commons.jcr.JcrConstants;
import com.day.cq.search.PredicateGroup;
import com.day.cq.search.Query;
import com.day.cq.search.QueryBuilder;
import com.day.cq.search.result.SearchResult;
import com.day.cq.wcm.api.NameConstants;

@Model(adaptables = SlingHttpServletRequest.class, adapters = CFModelDataSource.class, defaultInjectionStrategy = DefaultInjectionStrategy.OPTIONAL)
public class CFModelDataSourceImpl implements CFModelDataSource{
	@Self
    private SlingHttpServletRequest request;
    
    private List<Resource> resources = new LinkedList<>();

    public List<Resource> getResources() {
		return resources;
	}

	@PostConstruct
    public void init() {
    	ResourceResolver resourceResolver = request.getResourceResolver();
    	 QueryBuilder queryBuilder = resourceResolver.adaptTo(QueryBuilder.class);
         if (queryBuilder != null) {
             Map<String, String> parameterMap = new HashMap<>();
             parameterMap.put("path", "/conf");
             parameterMap.put("type", NameConstants.NN_TEMPLATE);
             parameterMap.put("p.limit", "-1");
             parameterMap.put("1_property", JcrConstants.JCR_CONTENT + "/model/" + ResourceResolver.PROPERTY_RESOURCE_TYPE);
             parameterMap.put("1_property.value", "wcm/scaffolding/components/scaffolding");
             
             PredicateGroup predicateGroup = PredicateGroup.create(parameterMap);
             Session session = resourceResolver.adaptTo(Session.class);
             Query query = queryBuilder.createQuery(predicateGroup, session);

             SearchResult searchResult = query.getResult();
         
             ContentFragmentUtils.createModelDataSource(resources, resourceResolver, searchResult);
         }
    }
    
public static void createModelDataSource(List<Resource> cfModels, ResourceResolver resourceResolver,
			SearchResult searchResult) {
		ResourceResolver leakingResourceResolver = null;
		try {
			for (Iterator<Resource> resourceIterator = searchResult.getResources(); resourceIterator.hasNext();) {
				Resource resource = resourceIterator.next();
				if (leakingResourceResolver == null) {
					// Get a reference to query builder's leaking resource resolver
					leakingResourceResolver = resource.getResourceResolver();
				}
				ValueMap modelValueMap = resource.getValueMap();
				String modelTitle = modelValueMap.get(JcrConstants.JCR_CONTENT + "/" + JcrConstants.JCR_TITLE,
						resource.getName());
				String modelPath = resource.getPath();
				Resource syntheticResource = ContentFragmentUtils.createResource(resourceResolver, modelTitle, modelPath);
				cfModels.add(syntheticResource);
			}
		} finally {
			if (leakingResourceResolver != null) {
				leakingResourceResolver.close();
			}
		}
	}


public static Resource createResource(@NotNull ResourceResolver resolver, @NotNull String textValue, @NotNull String valueValue) {
        ValueMap properties = new ValueMapDecorator(new HashMap<>());
        properties.put("text", textValue);
        properties.put("value", valueValue);
        return new ValueMapResource(resolver, new ResourceMetadata(), RESOURCE_TYPE_NON_EXISTING, properties);
    }
}
